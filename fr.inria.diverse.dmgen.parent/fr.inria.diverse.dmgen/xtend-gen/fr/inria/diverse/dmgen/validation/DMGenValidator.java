/**
 * generated by Xtext 2.10.0
 */
package fr.inria.diverse.dmgen.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import fr.inria.diverse.dmgen.dMGen.Clazz;
import fr.inria.diverse.dmgen.dMGen.DMGenPackage;
import fr.inria.diverse.dmgen.dMGen.Metamodel;
import fr.inria.diverse.dmgen.dMGen.Property;
import fr.inria.diverse.dmgen.dMGen.URI;
import fr.inria.diverse.dmgen.validation.AbstractDMGenValidator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.emf.ecore.xmi.impl.EcoreResourceFactoryImpl;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class DMGenValidator extends AbstractDMGenValidator {
  public final static String INVALID_NAME = "invalidName";
  
  public final static String DUPLICATE_CLASS_NAME = "duplicateClass";
  
  public final static String DUPLICATE_PROPERTY_NAME = "duplicateClass";
  
  public final static String CLASS_NOT_FOUND = "ClassNotFound";
  
  public final static String PROPERTY_NOT_FOUND = "PropertyNotFound";
  
  public static Set<EPackage> importedPackages;
  
  /**
   * Checking if class names do not start with Capital
   */
  @Check
  public void checkClassStartsWithCapital(final Clazz clazz) {
    String _name = clazz.getName();
    char _charAt = _name.charAt(0);
    boolean _isUpperCase = Character.isUpperCase(_charAt);
    boolean _not = (!_isUpperCase);
    if (_not) {
      this.warning("Name should start with a capital", 
        DMGenPackage.Literals.CLAZZ__NAME, 
        DMGenValidator.INVALID_NAME);
    }
  }
  
  /**
   * Checking if class names are not duplicated
   */
  @Check
  public void checkDuplicateClazzNames(final Clazz clazz) {
    EObject _eContainer = clazz.eContainer();
    Object _eGet = _eContainer.eGet(DMGenPackage.Literals.GENERATOR__CLASSES);
    final EList<Clazz> allClasses = ((EList<Clazz>) _eGet);
    final Function1<Clazz, Boolean> _function = (Clazz clz) -> {
      String _name = clz.getName();
      String _name_1 = clazz.getName();
      return Boolean.valueOf(_name.equals(_name_1));
    };
    Iterable<Clazz> _filter = IterableExtensions.<Clazz>filter(allClasses, _function);
    int _size = IterableExtensions.size(_filter);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      this.error("Duplicate class name", DMGenPackage.Literals.CLAZZ__NAME, DMGenValidator.DUPLICATE_CLASS_NAME);
    }
  }
  
  /**
   * Checking if property names are not duplicated within the same Class
   */
  @Check
  public void duplicatePropertyName(final Property property) {
    EObject _eContainer = property.eContainer();
    Object _eGet = _eContainer.eGet(DMGenPackage.Literals.CLAZZ__PROPERTIES);
    final EList<Property> allProperties = ((EList<Property>) _eGet);
    final Function1<Property, Boolean> _function = (Property prop) -> {
      String _name = prop.getName();
      String _name_1 = property.getName();
      return Boolean.valueOf(_name.equals(_name_1));
    };
    Iterable<Property> _filter = IterableExtensions.<Property>filter(allProperties, _function);
    int _size = IterableExtensions.size(_filter);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      this.error("Duplicate property name", DMGenPackage.Literals.PROPERTY__NAME, DMGenValidator.DUPLICATE_PROPERTY_NAME);
    }
  }
  
  /**
   * Checking if Class name exists in imported metamodel
   */
  @Check
  public void checkClassNotFound(final Clazz clazz) {
    Set<EPackage> __importedPackages = this._importedPackages(clazz);
    final Function1<EPackage, EList<EClassifier>> _function = (EPackage ePck) -> {
      return ePck.getEClassifiers();
    };
    Iterable<EList<EClassifier>> _map = IterableExtensions.<EPackage, EList<EClassifier>>map(__importedPackages, _function);
    Iterable<EClassifier> _flatten = Iterables.<EClassifier>concat(_map);
    final Function1<EClassifier, String> _function_1 = (EClassifier eCls) -> {
      return eCls.getName();
    };
    Iterable<String> _map_1 = IterableExtensions.<EClassifier, String>map(_flatten, _function_1);
    final Iterable<String> allClassNames = ((Iterable<String>) _map_1);
    final Function1<String, Boolean> _function_2 = (String str) -> {
      String _name = clazz.getName();
      return Boolean.valueOf(str.equals(_name));
    };
    boolean _exists = IterableExtensions.<String>exists(allClassNames, _function_2);
    boolean _not = (!_exists);
    if (_not) {
      String _name = clazz.getName();
      String _plus = ("Unable to find a class with name: " + _name);
      this.error(_plus, DMGenPackage.Literals.CLAZZ__NAME, DMGenValidator.CLASS_NOT_FOUND);
    }
  }
  
  /**
   * Checking if Property name exists in imported metamodel
   */
  @Check
  public void checkPropertyNotFound(final Property property) {
    final Object className = property.eGet(DMGenPackage.Literals.CLAZZ__NAME);
    Set<EPackage> __importedPackages = this._importedPackages(property);
    final Function1<EPackage, EList<EClassifier>> _function = (EPackage ePck) -> {
      return ePck.getEClassifiers();
    };
    Iterable<EList<EClassifier>> _map = IterableExtensions.<EPackage, EList<EClassifier>>map(__importedPackages, _function);
    Iterable<EClassifier> _flatten = Iterables.<EClassifier>concat(_map);
    final Function1<EClassifier, Boolean> _function_1 = (EClassifier eCls) -> {
      String _name = eCls.getName();
      return Boolean.valueOf(_name.equals(className));
    };
    EClassifier _findFirst = IterableExtensions.<EClassifier>findFirst(_flatten, _function_1);
    Object _eGet = _findFirst.eGet(DMGenPackage.Literals.CLAZZ__PROPERTIES);
    final EList<Property> allProperties = ((EList<Property>) _eGet);
    final Function1<Property, String> _function_2 = (Property prop) -> {
      return prop.getName();
    };
    List<String> _map_1 = ListExtensions.<Property, String>map(allProperties, _function_2);
    String _name = property.getName();
    boolean _contains = _map_1.contains(_name);
    boolean _not = (!_contains);
    if (_not) {
      String _name_1 = property.getName();
      String _plus = ("Unable to find a property with name: " + _name_1);
      this.error(_plus, 
        DMGenPackage.Literals.PROPERTY__NAME, DMGenValidator.PROPERTY_NOT_FOUND);
    }
  }
  
  /**
   * Loading the
   */
  public Set<EPackage> _importedPackages(final EObject model) {
    boolean _equals = Objects.equal(DMGenValidator.importedPackages, null);
    if (_equals) {
      Resource resource = model.eResource();
      HashSet<EPackage> _hashSet = new HashSet<EPackage>();
      DMGenValidator.importedPackages = _hashSet;
      TreeIterator<EObject> _allContents = resource.getAllContents();
      final Function1<EObject, Boolean> _function = (EObject e) -> {
        return Boolean.valueOf((e instanceof Metamodel));
      };
      Iterator<EObject> _filter = IteratorExtensions.<EObject>filter(_allContents, _function);
      final Function1<EObject, Metamodel> _function_1 = (EObject e) -> {
        return ((Metamodel) e);
      };
      Iterator<Metamodel> _map = IteratorExtensions.<EObject, Metamodel>map(_filter, _function_1);
      final Function1<Metamodel, URI> _function_2 = (Metamodel m) -> {
        return m.getUri();
      };
      Iterator<URI> _map_1 = IteratorExtensions.<Metamodel, URI>map(_map, _function_2);
      final Procedure1<URI> _function_3 = (URI uri) -> {
        List<EPackage> _loadAllpackagesOfURI = this.loadAllpackagesOfURI(uri);
        DMGenValidator.importedPackages.addAll(_loadAllpackagesOfURI);
      };
      IteratorExtensions.<URI>forEach(_map_1, _function_3);
    }
    return DMGenValidator.importedPackages;
  }
  
  public List<EPackage> loadAllpackagesOfURI(final URI uri) {
    final ResourceSetImpl resourceSet = new ResourceSetImpl();
    Resource.Factory.Registry _resourceFactoryRegistry = resourceSet.getResourceFactoryRegistry();
    Map<String, Object> _extensionToFactoryMap = _resourceFactoryRegistry.getExtensionToFactoryMap();
    EcoreResourceFactoryImpl _ecoreResourceFactoryImpl = new EcoreResourceFactoryImpl();
    _extensionToFactoryMap.put(
      EcorePackage.eNS_PREFIX, _ecoreResourceFactoryImpl);
    String _prettyString = this.toPrettyString(uri);
    org.eclipse.emf.common.util.URI _createURI = org.eclipse.emf.common.util.URI.createURI(_prettyString);
    final Resource resource = resourceSet.getResource(_createURI, true);
    TreeIterator<EObject> _allContents = resource.getAllContents();
    final Function1<EObject, Boolean> _function = (EObject e) -> {
      return Boolean.valueOf((e instanceof EPackage));
    };
    Iterator<EObject> _filter = IteratorExtensions.<EObject>filter(_allContents, _function);
    final Function1<EObject, EPackage> _function_1 = (EObject pck) -> {
      return ((EPackage) pck);
    };
    Iterator<EPackage> _map = IteratorExtensions.<EObject, EPackage>map(_filter, _function_1);
    return IteratorExtensions.<EPackage>toList(_map);
  }
  
  public String toPrettyString(final URI uri) {
    StringBuffer buff = new StringBuffer();
    String _scheme = uri.getScheme();
    buff.append(_scheme);
    String _authority = uri.getAuthority();
    boolean _isEmpty = _authority.isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      String _authority_1 = uri.getAuthority();
      buff.append(_authority_1);
      buff.append("/");
    }
    EList<String> _fragments = uri.getFragments();
    for (final String s : _fragments) {
      {
        buff.append(s);
        buff.append("/");
      }
    }
    String result = buff.toString();
    int _length = result.length();
    int _minus = (_length - 1);
    return result.substring(0, _minus);
  }
}
