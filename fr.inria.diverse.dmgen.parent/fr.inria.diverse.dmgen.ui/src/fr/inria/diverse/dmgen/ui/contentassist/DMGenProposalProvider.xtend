/*
 * generated by Xtext 2.10.0
 */
package fr.inria.diverse.dmgen.ui.contentassist

import fr.inria.diverse.dmgen.dMGen.Metamodel
import fr.inria.diverse.dmgen.dMGen.URI
import java.util.HashSet
import java.util.Set
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.EcorePackage
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl
import org.eclipse.emf.ecore.xmi.impl.EcoreResourceFactoryImpl
import org.eclipse.xtext.RuleCall
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor
import fr.inria.diverse.dmgen.dMGen.Clazz

/**
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#content-assist
 * on how to customize the content assistant.
 */
 
class DMGenProposalProvider extends AbstractDMGenProposalProvider {
	
	 // FIXME very dirty way to enhance the contentAssist. 
	 // Shall find a better way
	
	Set<EPackage> importedPackages
		 
	override complete_Clazz(EObject model, 
							RuleCall ruleCall, 
							ContentAssistContext context, 
							ICompletionProposalAcceptor acceptor) {
								
		super.complete_Clazz(model, ruleCall, context, acceptor);
		_importedPackages(model).map[pck | pck.EClassifiers]
						   .flatten
						   .filter[ c | c instanceof EClass]
						   .map[c | c.name]
						   .forEach[element| acceptor
						   		.accept(createCompletionProposal(element, element,null,context))
						   ]
	}
	
	override complete_Property(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		super.complete_Property(model, ruleCall, context, acceptor)
		val myClazz = model as Clazz
		
		val currentClass = _importedPackages(model).map[pck | pck.EClassifiers]
			  					   .flatten
			  					   .filter [eCls | eCls instanceof EClass]
								   .findFirst[c | c.name.equals(myClazz.name)] as EClass
								   
	  	currentClass.EReferences.map[eRef | eRef.name]
	  							.forEach[ name | acceptor.accept(createCompletionProposal(name,name,null,context))]
	  }	

	
	def _importedPackages(EObject model) {
		var resource = model.eResource
		importedPackages = new HashSet<EPackage>
		resource.allContents
				.filter[e | e instanceof Metamodel]
				.map[e | e as Metamodel]
				.map[m | m.uri]
				.forEach[uri | importedPackages.addAll(loadAllpackagesOfURI(uri))]
				
		return importedPackages
	}
	
	
	def loadAllpackagesOfURI(URI uri) {
		
		val resourceSet = new ResourceSetImpl();
		{ // initializing the registry
			
			resourceSet.getResourceFactoryRegistry().getExtensionToFactoryMap().put(
					EcorePackage.eNS_PREFIX, new EcoreResourceFactoryImpl());
		}
		
		val resource = resourceSet.getResource(
			org.eclipse.emf.common.util.URI.createURI(uri.toPrettyString), true);
		
		return resource.allContents.filter[e | e instanceof EPackage].map[pck | pck as EPackage].toList
	}
	
	def String toPrettyString(URI uri) {
		var buff = new StringBuffer()
    
	    buff.append(uri.scheme);
	    //buff.append("://");
	    if (! uri.authority.isEmpty) {
	    	buff.append(uri.authority)
	    	buff.append('/')
	    }
	    for (String s : uri.fragments) {	
	    	buff.append(s)
	    	buff.append('/')
	    }
	   var result = buff.toString
	   
	   return result.substring(0, result.length - 1)
	}
	
	
	
	
	

}
